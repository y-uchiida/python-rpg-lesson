# 開発パート03: フィールドでの連続戦闘を実装する

今回のパートでは、敵キャラクターと連続で戦闘が発生するように改修を加えます。  
戦闘の開始を「敵と遭遇するフィールドへ出た」という設定と考え、複数の敵キャラクターに出会う状況を再現しましょう。  
また、味方キャラクターも複数扱えるように拡張して、ゲーム性を高めていきます。  

## 1. Field クラスの作成

新たに`Field.py` を作成し、その中にField クラスを作成します。

Field クラスに設定すべきメンバ変数は、以下の通りです。

項目名 | アクセス属性 | 型 | 備考
--- | --- | --- | ---
敵キャラ一覧 | private | list[Monster] | Monster オブジェクトを要素に持つリスト。

また、コンストラクタを設定し、field オブジェクトを生成できるようにします。  
Field オブジェクトの生成時に、敵キャラ一覧のリストに、複数の敵キャラクターを追加できるようにしておきましょう。

## 2. 味方キャラクターのオブジェクトを複数持てるようにする

Field オブジェクト上に敵キャラクターを複数配置したので、味方キャラクターも複数連れていけるようにします。  
`main.py` でキャラクターの作成を行うとき、リストを使って味方キャラクターを複数作成します。

## 3. main.py の改修

敵キャラクター、味方キャラクターのオブジェクトを複数作成することができたら、今度は`main.py`を書き換えていきます。  
いくつかの変更点があります。  

### 1. 戦闘処理を、別の関数として切り出す

`main.py` で新しく処理を追加していく前に、現在のコードを整理します。  
まずは、今後何度も実行することになる戦闘の場面を、別の関数に切り分けていきます。  

すべての処理が`main.py` にそのまま記述されていると、とてもコードが長くなり、わかりづらくなってしまいます。  
これを防ぐため、内容のまとまりごとに別の関数に分割し、処理内容の見通しをよくします。

`battle()` 関数を新たに作成し、戦闘部分の処理をこちらに移動させましょう。  

`battle()` 関数には、引数として味方キャラクターの一覧と、敵キャラクターの一覧（field）をわたします。  
`battle()` 関数内でキャラクターを操作するためには、データを引き渡しておく必要があるためです。

## 2. 複数のモンスターとの連続した戦闘を実装する

分割した`battle()` 関数に、新たな処理を追加していきましょう。  
味方キャラクターのリストの最初のキャラクターと、Field(敵キャラクターの一覧) の中の最初のキャラクターが戦闘を行うように作ります。  

勝利した場合は、Field オブジェクト内の次の敵キャラクターとの戦闘を開始します。  
こうして、Field から敵キャラクターがすべていなくなるまで戦闘を行っていくように実装しましょう。

リストの戦闘の味方キャラクターが戦闘不能になった場合は、リスト内の次の味方キャラクターが戦闘を行います。  
味方キャラクターが全て戦闘不能になった場合は、ゲームオーバーとしてプログラムを終了します。

Field のすべての敵キャラクターを倒したら、つぎの戦闘を開始するか、休憩をするかの選択に戻ります。  

:::info
field の敵モンスターの数をランダムで決める機能を追加する場合や、戦闘の合間のコマンドなどを実装するときに備えて、連続戦闘の繰り返しの条件は「敵モンスターがいなくなるか、味方モンスターがいなくなる」を設定するようにしましょう
:::

## 3. 動作の確認

複数の敵キャラクターとの連続した戦闘が実施できるようになったら、動作に問題がないかを確かめていきます。  
すくなくとも、以下のパターンでエラーが起こらないことを確認してください。

:white_check_mark: 味方キャラクターがすべて負けてしまった場合  
:white_check_mark: 敵キャラクターをすべて倒した場合  
:white_check_mark: 敵キャラクターをすべて倒して、再度戦闘を開始した場合  

## 余裕のある方への追加ミッション

### 1. 味方キャラクターのリストの取り扱い方を工夫する

`main.py` の中はなるべくシンプルに保つのが望ましいです。  
味方キャラクターのリストを`main.py` の中にそのまま記述するのではなく、別の方法で管理するようにしてみましょう。  

実装方法はいくつか考えられるので、工夫してみてください。
